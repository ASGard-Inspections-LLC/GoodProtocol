import { default as hre, ethers, upgrades } from "hardhat";
import { expect } from "chai";
import { GoodMarketMaker, CERC20, GoodReserveCDai, GoodCap } from "../../types";
import { createDAO, increaseTime, advanceBlocks } from "../helpers";
import { Contract } from "@ethersproject/contracts";

const BN = ethers.BigNumber;
export const NULL_ADDRESS = ethers.constants.AddressZero;
export const BLOCK_INTERVAL = 1;

describe("GoodCap", () => {
  let goodReserve: GoodReserveCDai;
  let goodDollar: Contract,
    avatar,
    controller,
    founder,
    staker,
    granted,
    schemeMock,
    signers,
    setDAOAddress,
    goodCap: GoodCap;

  before(async () => {
    [founder, staker, granted, ...signers] = await ethers.getSigners();
    schemeMock = signers.pop();

    let {
      controller: ctrl,
      avatar: av,
      gd,
      identity,
      daoCreator,
      nameService,
      setDAOAddress: sda,
      setSchemes,
      marketMaker: mm,
      daiAddress,
      cdaiAddress
    } = await createDAO();

    avatar = av;
    controller = ctrl;
    setDAOAddress = sda;

    console.log("deployed dao", {
      founder: founder.address,
      gd,
      identity,
      controller,
      avatar
    });

    goodDollar = await ethers.getContractAt("GoodDollar", gd);

    const reserveFactory = await ethers.getContractFactory("GoodReserveCDai");

    console.log("deployed contribution, deploying reserve...", {
      founder: founder.address
    });

    goodReserve = (await upgrades.deployProxy(
      reserveFactory,
      [
        nameService.address,
        //check sample merkle tree generated by gdxAirdropCalculation.ts script
        "0x26ef809f3f845395c0bc66ce1eea85146516cb99afd030e2085b13e79514e94c"
      ],
      {
        initializer: "initialize(address, bytes32)"
      }
    )) as GoodReserveCDai;

    console.log("setting permissions...");

    //give reserve generic call permission
    await setSchemes([goodReserve.address, schemeMock.address]);

    goodCap = (await upgrades.deployProxy(
      await ethers.getContractFactory("GoodCap"),
      [nameService.address, 1000000]
    )) as GoodCap;
  });

  it("should not be able to mint if not minter", async () => {
    await expect(goodCap.mint(founder.address, 10)).to.be.revertedWith(
      "GoodCap: not a minter"
    );
  });

  it("should not be able to mint if GoodCap not given GoodDollar minter role by DAO", async () => {
    await setDAOAddress("RESERVE", founder.address);

    await expect(goodCap.mint(founder.address, 10)).to.be.reverted;
  });

  it("should be able to mint if core contract and GoodCap is minter", async () => {
    let encodedCall = goodDollar.interface.encodeFunctionData("addMinter", [
      goodCap.address
    ]);
    const ictrl = await ethers.getContractAt(
      "Controller",
      controller,
      schemeMock
    );

    await ictrl.genericCall(goodDollar.address, encodedCall, avatar, 0);

    await goodCap.connect(founder).mint(founder.address, 10);
    expect(await goodDollar.balanceOf(founder.address)).to.equal(10);
  });

  it("should be able to mint after Avatar renounceMinter", async () => {
    expect(await goodDollar.isMinter(avatar)).to.be.true;

    let encodedCall = goodDollar.interface.encodeFunctionData(
      "renounceMinter",
      []
    );
    const ictrl = await ethers.getContractAt(
      "Controller",
      controller,
      schemeMock
    );

    await ictrl.genericCall(goodDollar.address, encodedCall, avatar, 0);

    expect(await goodDollar.isMinter(avatar)).to.be.false;
    await goodCap.connect(founder).mint(founder.address, 10);
    expect(await goodDollar.balanceOf(founder.address)).to.equal(20);
  });

  it("should not be able to mint if not core contract and GoodCap is minter", async () => {
    await setDAOAddress("RESERVE", staker.address);

    let encodedCall = goodDollar.interface.encodeFunctionData("addMinter", [
      goodCap.address
    ]);
    const ictrl = await ethers.getContractAt(
      "Controller",
      controller,
      schemeMock
    );

    await ictrl.genericCall(goodDollar.address, encodedCall, avatar, 0);

    await expect(
      goodCap.connect(founder).mint(founder.address, 10)
    ).to.be.revertedWith("GoodCap: not a minter");
  });

  it("should not be able to grant minter role if not Avatar", async () => {
    await expect(
      goodCap.grantRole(await goodCap.MINTER_ROLE(), granted.address)
    ).to.be.revertedWith("AccessControl: sender must be an admin to grant");
  });

  it("should be able to grant minter role if Avatar", async () => {
    let encodedCall = goodCap.interface.encodeFunctionData("grantRole", [
      await goodCap.MINTER_ROLE(),
      granted.address
    ]);
    const ictrl = await ethers.getContractAt(
      "Controller",
      controller,
      schemeMock
    );

    await ictrl.genericCall(goodCap.address, encodedCall, avatar, 0);
    expect(await goodCap.hasRole(await goodCap.MINTER_ROLE(), granted.address))
      .to.be.true;
  });

  it("should be able to mint if granted role", async () => {
    await goodCap.connect(granted).mint(founder.address, 10);
    expect(await goodDollar.balanceOf(founder.address)).to.equal(30);
  });

  it("should enforce cap", async () => {
    await expect(
      goodCap.connect(granted).mint(founder.address, 1000000)
    ).to.be.revertedWith("GoodCap: cap enforced");
  });

  it("should be able to revoke minter role if Avatar", async () => {
    let encodedCall = goodCap.interface.encodeFunctionData("revokeRole", [
      await goodCap.MINTER_ROLE(),
      granted.address
    ]);
    const ictrl = await ethers.getContractAt(
      "Controller",
      controller,
      schemeMock
    );

    await ictrl.genericCall(goodCap.address, encodedCall, avatar, 0);
    expect(await goodCap.hasRole(await goodCap.MINTER_ROLE(), granted.address))
      .to.be.false;
  });

  it("should not have cap on mintTokens if not registered as GlobalConstraint", async () => {
    const ictrl = await ethers.getContractAt(
      "Controller",
      controller,
      schemeMock
    );

    await expect(ictrl.mintTokens(1000000, granted.address, avatar)).to.not
      .reverted; //cap not passed
    expect(await goodDollar.balanceOf(granted.address)).to.equal(1000000);
    await goodDollar.connect(granted).burn(1000000);
  });

  it("should enforce cap on Controller mintToken if registered as GlobalConstraint", async () => {
    const ictrl = await ethers.getContractAt(
      "Controller",
      controller,
      schemeMock
    );

    await ictrl.addGlobalConstraint(
      goodCap.address,
      ethers.constants.HashZero,
      avatar
    );

    await expect(ictrl.mintTokens(10, granted.address, avatar)).to.not.reverted; //cap not passed
    expect(await goodDollar.balanceOf(granted.address)).to.equal(10);
    await expect(ictrl.mintTokens(1000000, founder.address, avatar)).to.be
      .reverted;
  });
});
